//#include <iostream>
//
//
///*
//* 기본적으로 1 * 2 * 3 * 4.......* (n-1) * n 을 소인수분해 했을 때, 2와 5가 몇개인지.
//* M이 0의 개수라고 했을 때, (2^M * 5^M) * k 꼴이 성립해야함.
//* 
//* 2의 개수는 항상 5의 개수보다 많을 수 밖에 없음.
//* 즉, 5의 개수만 검사하면 됨.
//* 1~N을 반복문으로 검사하며, 현재 인덱스가 가지고 있는 소인수 5 의 개수를 찾아서 계속 더한다.
//* 이러한 원리때문에, 반복문은 1단위가 아닌 5단위씩 넘어가면서 검사한다.
//* 
//* 5의 개수가 0의 개수보다 많거나 같아지는 순간 반복문들 탈출.
//* 5의 개수 == 0의 개수라면, 반복문을 탈출한 시점의 인덱스가 최소 N이다.
//* 5의 개수 > 0의 개수라면, 답이 존재하지 않으므로 -1을 리턴.
//*/
//int main()
//{
//	std::ios::sync_with_stdio(false);
//	std::cin.tie(0);
//	std::cout.tie(0);
//
//	int NumOfZero = 0;
//	std::cin >> NumOfZero;
//
//	int Num_5 = 0;
//
//	int Num = 0;
//
//	while (true)
//	{
//		Num += 5;
//
//		int Copy_5 = Num;
//
//		while (Copy_5 % 5 == 0)
//		{
//			Num_5++;
//			Copy_5 /= 5;
//		}
//
//		if (Num_5 >= NumOfZero)
//		{
//			break;
//		}
//	}
//
//
//	if (Num_5 == NumOfZero)
//	{
//		std::cout << Num;
//	}
//	else
//	{
//		std::cout << -1;
//	}
//
//	return 0;
//}